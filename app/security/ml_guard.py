"""
===============================================================================
ML-BASED ЗАЩИТА ОТ SQL INJECTION
===============================================================================

НАЗНАЧЕНИЕ:
----------
Использует обученную ML модель для обнаружения SQL injection атак.
Модель обучена на датасете безопасных и вредоносных SQL запросов.

ПАТТЕРН ПРОЕКТИРОВАНИЯ: SINGLETON
---------------------------------
Класс использует паттерн Singleton для обеспечения:
- Одного экземпляра модели на все приложение
- Экономии памяти (модель загружается один раз)
- Thread-safety (безопасность в многопоточности)

АДАПТИВНЫЙ ПОРОГ:
---------------
Использует два порога принятия решения:
- Обычный порог (0.7367) - для стандартных запросов
- Строгий порог (0.65) - для запросов с подозрительными признаками

Это позволяет быть более строгими к потенциально опасным запросам,
но не блокировать нормальные запросы с высоким false positive rate.
"""

# app/security/ml_guard.py
import joblib
# joblib - библиотека для сохранения/загрузки ML моделей
# Альтернатива pickle, но оптимизирована для больших numpy массивов
# Используется scikit-learn для сохранения моделей

import threading
# threading - работа с потоками
# Используется для thread-safe Singleton паттерна

import re
# re - регулярные выражения
# Используется для обнаружения подозрительных признаков

class MLSQLGuard:
    """
    Класс для ML-based проверки SQL запросов на наличие injection атак.
    
    АРХИТЕКТУРА:
    -----------
    Использует паттерн Singleton для обеспечения единственного экземпляра.
    Модель загружается один раз при первом обращении.
    
    МОДЕЛЬ:
    ------
    - Формат: scikit-learn Pipeline (вероятно, TF-IDF + классификатор)
    - Файл: sql_injection_model.pkl
    - Тип: вероятно, LogisticRegression или RandomForest
    - Вход: SQL запрос как строка
    - Выход: вероятность того, что запрос - SQL injection (0.0 - 1.0)
    """
    
    # Классовые переменные для Singleton паттерна
    _instance = None  # Единственный экземпляр класса
    _lock = threading.Lock()  # Блокировка для thread-safety

    def __init__(self):
        """
        Приватный конструктор (вызывается только через instance()).
        
        ИНИЦИАЛИЗАЦИЯ:
        -------------
        1. Загрузка ML модели из файла
        2. Установка порогов принятия решения
        
        ПОЧЕМУ ПРИВАТНЫЙ:
        ---------------
        Чтобы предотвратить создание множественных экземпляров.
        Используйте MLSQLGuard.instance() для получения экземпляра.
        """
        # Загрузка модели из файла
        # joblib.load() восстанавливает полный объект модели (Pipeline)
        # Модель содержит:
        # - Векторизатор (TF-IDF или CountVectorizer)
        # - Классификатор (LogisticRegression, RandomForest и т.д.)
        # - Все параметры обучения
        self.model = joblib.load("sql_injection_model.pkl")
        
        # Порог принятия решения (настроен на обучении)
        # Если вероятность SQL injection >= threshold, запрос блокируется
        # Значение 0.7367 означает, что модель должна быть уверена на 73.67%
        # Это значение получено при обучении модели (вероятно, через ROC curve)
        self.threshold = 0.7367346938775511
        
        # Более строгий порог для подозрительных случаев
        # Используется когда запрос содержит подозрительные признаки
        # (UNION, OR 1=1, комментарии и т.д.)
        # Более низкий порог = более строгая проверка
        self.strict_threshold = 0.65

    @classmethod
    def instance(cls):
        """
        Получить единственный экземпляр класса (Singleton паттерн).
        
        SINGLETON ПАТТЕРН:
        -----------------
        Обеспечивает создание только одного экземпляра класса.
        Это важно для ML модели, так как:
        - Модель занимает много памяти
        - Загрузка модели медленная
        - Нет смысла иметь несколько копий
        
        DOUBLE-CHECKED LOCKING:
        ----------------------
        Используется оптимизированная версия Singleton:
        1. Первая проверка без блокировки (быстро)
        2. Если нет экземпляра - берем блокировку
        3. Вторая проверка внутри блокировки (защита от race condition)
        4. Создаем экземпляр если его все еще нет
        
        THREAD-SAFETY:
        -------------
        threading.Lock() обеспечивает, что только один поток
        может создать экземпляр одновременно.
        Это защищает от race condition в многопоточных приложениях.
        
        ВОЗВРАЩАЕТ:
            MLSQLGuard - единственный экземпляр класса
            
        ПРИМЕР:
            guard1 = MLSQLGuard.instance()
            guard2 = MLSQLGuard.instance()
            # guard1 и guard2 - это один и тот же объект
            assert guard1 is guard2  # True
        """
        # Первая проверка без блокировки (оптимизация производительности)
        # Если экземпляр уже существует, сразу возвращаем его
        if not cls._instance:
            # Берем блокировку для thread-safety
            # with statement автоматически освобождает блокировку
            with cls._lock:
                # Вторая проверка внутри блокировки
                # Это защищает от ситуации, когда два потока одновременно
                # прошли первую проверку и оба пытаются создать экземпляр
                if not cls._instance:
                    # Создаем единственный экземпляр
                    cls._instance = cls()
        return cls._instance

    def _has_suspicious_features(self, sql: str) -> bool:
        """Проверяет наличие подозрительных признаков, которые требуют более строгой проверки"""
        s = sql.lower()
        
        # Подозрительные паттерны, которые требуют более низкого порога
        suspicious = [
            r"union.*select",
            r"or\s+1\s*=\s*1",
            r"and\s+1\s*=\s*1",
            r"exec\s*\(",
            r"execute\s*\(",
            r"pg_sleep",
            r"sleep\s*\(",
            r"information_schema",
            r"0x[0-9a-f]+",
            r"--",
            r"/\*",
        ]
        
        for pattern in suspicious:
            if re.search(pattern, s, re.IGNORECASE):
                return True
        
        # Подозрительное количество специальных символов
        special_chars = sum(1 for c in sql if c in "()[]{}\"'`;")
        if special_chars > 20:
            return True
        
        return False

    def check(self, sql: str) -> tuple[bool, float]:
        """
        Проверяет SQL запрос с помощью ML модели.
        Возвращает (is_malicious, risk_score)
        """
        try:
            proba = self.model.predict_proba([sql])[0][1]
            
            # Если есть подозрительные признаки, используем более строгий порог
            threshold = self.strict_threshold if self._has_suspicious_features(sql) else self.threshold
            
            is_malicious = proba >= threshold
            
            return is_malicious, proba
        except Exception as e:
            # В случае ошибки модели, лучше заблокировать (fail-safe)
            # Но можно логировать для отладки
            return True, 1.0
