"""
===============================================================================
СИСТЕМА ЗАЩИТЫ ОТ SQL INJECTION - ГЛАВНЫЙ МОДУЛЬ
===============================================================================

НАЗНАЧЕНИЕ:
----------
Этот модуль реализует многослойную систему защиты от SQL injection атак.
Использует комбинацию whitelist, rule-based и ML-based проверок.

АРХИТЕКТУРА ЗАЩИТЫ:
------------------
1. WHITELIST - быстрая проверка известных безопасных паттернов
   - Пропускает простые SELECT запросы без проверки
   - Экономит ресурсы на очевидных случаях
   
2. STRUCTURE VALIDATION - проверка структуры запроса
   - Длина запроса (защита от DoS)
   - Подозрительные символы
   - Количество кавычек
   
3. RULE-BASED - проверка известных паттернов атак
   - UNION injection
   - Boolean-based injection
   - Time-based injection
   - Stacked queries
   
4. ML-BASED - машинное обучение для обнаружения сложных атак
   - Обученная модель на датасете SQL injection атак
   - Обнаруживает новые/неизвестные паттерны

ПРИНЦИП РАБОТЫ:
--------------
Запрос проходит через все уровни защиты последовательно.
Если любой уровень блокирует - запрос отклоняется.
Только если все уровни разрешают - запрос выполняется.

ПРЕИМУЩЕСТВА МНОГОСЛОЙНОЙ ЗАЩИТЫ:
---------------------------------
- Defense in Depth: если один слой пропустит, другой поймает
- Разные подходы: regex + ML покрывают разные типы атак
- Адаптивность: ML может обнаружить новые паттерны
- Производительность: whitelist быстро пропускает безопасные запросы
"""

# app/security/sql_guard.py
import re
# re - регулярные выражения для проверки паттернов

from app.security.rule_based import rule_based_check, normalize_sql
# rule_based_check - функция rule-based проверки
# normalize_sql - нормализация SQL (удаление комментариев, пробелов)

from app.security.ml_guard import MLSQLGuard
# MLSQLGuard - класс для ML-based проверки
# Использует обученную модель для обнаружения SQL injection

# ============================================================================
# WHITELIST БЕЗОПАСНЫХ SQL ПАТТЕРНОВ
# ============================================================================
# 
# НАЗНАЧЕНИЕ:
# ----------
# Быстрая проверка для известных безопасных запросов.
# Если запрос соответствует одному из паттернов - сразу разрешаем,
# не тратя ресурсы на rule-based и ML проверки.
#
# ПРЕИМУЩЕСТВА:
# ------------
# - Производительность: O(1) проверка вместо O(n) для ML
# - Низкая нагрузка: не нужно загружать ML модель для простых запросов
# - Предсказуемость: известные безопасные запросы всегда проходят
#
# ПАТТЕРНЫ:
# --------
# Используются регулярные выражения для описания структуры безопасных запросов.
# Паттерны проверяются на нормализованном SQL (без комментариев, лишних пробелов).

SAFE_QUERY_WHITELIST = [
    # Простые SELECT запросы
    r"^\s*select\s+\*\s+from\s+\w+\s*;?\s*$",
    r"^\s*select\s+[\w\s,]+from\s+\w+\s*;?\s*$",
    r"^\s*select\s+[\w\s,]+from\s+\w+\s+where\s+[\w\s=<>'\"()]+;?\s*$",
    # SELECT с LIMIT
    r"^\s*select\s+.*?\s+from\s+\w+\s+limit\s+\d+\s*;?\s*$",
    # SELECT с ORDER BY
    r"^\s*select\s+.*?\s+from\s+\w+\s+order\s+by\s+\w+\s*;?\s*$",
    # WITH запросы
    r"^\s*with\s+\w+\s+as\s*\(.*?\)\s*select\s+.*?\s*;?\s*$",
    # EXPLAIN запросы
    r"^\s*explain\s+(analyze\s+)?\s*select\s+.*?\s*;?\s*$",
]

def is_whitelisted(sql: str) -> bool:
    """
    Проверяет, находится ли SQL запрос в whitelist безопасных паттернов.
    
    АЛГОРИТМ:
    1. Проверка комментариев на опасные команды
    2. Нормализация SQL (удаление комментариев, пробелов)
    3. Сопоставление с паттернами whitelist
    
    ВАЖНОСТЬ ПРОВЕРКИ КОММЕНТАРИЕВ:
    ------------------------------
    Атакующий может попытаться обойти whitelist, спрятав опасные команды
    в комментариях: "SELECT * FROM users; -- DROP TABLE users"
    Поэтому проверяем комментарии ДО нормализации.
    
    АРГУМЕНТЫ:
        sql: str - SQL запрос для проверки
        
    ВОЗВРАЩАЕТ:
        bool: True если запрос в whitelist, False если нет
        
    ПРИМЕРЫ:
        is_whitelisted("SELECT * FROM users") -> True
        is_whitelisted("SELECT * FROM users; -- DROP TABLE") -> False (опасный комментарий)
        is_whitelisted("DROP TABLE users") -> False (не в whitelist)
    """
    # ШАГ 1: Проверка комментариев на опасные команды
    # Проверяем ДО нормализации, так как normalize_sql удаляет комментарии
    # Это защита от атак типа: "SELECT * FROM users; -- DROP TABLE users"
    
    sql_lower = sql.lower()  # Приводим к нижнему регистру для case-insensitive проверки
    
    # Проверяем однострочные комментарии (-- до конца строки)
    # re.findall() находит все совпадения паттерна
    # r'--.*?$' - паттерн: -- затем любые символы до конца строки
    # re.MULTILINE - ^ и $ соответствуют началу/концу каждой строки
    single_line_comments = re.findall(r'--.*?$', sql, re.MULTILINE)
    for comment in single_line_comments:
        # Ищем опасные команды в комментарии
        # \b - граница слова (word boundary), чтобы не совпало "information" с "alter"
        # Список опасных команд: drop, delete, truncate, alter, create, insert, update, exec, execute, union, or 1=1
        dangerous_in_comment = re.search(
            r'\b(drop|delete|truncate|alter|create|insert|update|exec|execute|union|or\s+1\s*=\s*1)\b', 
            comment, 
            re.IGNORECASE
        )
        if dangerous_in_comment:
            # Найдена опасная команда в комментарии - не пропускаем через whitelist
            return False
    
    # Проверяем многострочные комментарии (/* ... */)
    # re.DOTALL - точка (.) соответствует также символу новой строки
    multi_line_comments = re.findall(r'/\*.*?\*/', sql, re.DOTALL)
    for comment in multi_line_comments:
        # Та же проверка для многострочных комментариев
        dangerous_in_comment = re.search(
            r'\b(drop|delete|truncate|alter|create|insert|update|exec|execute|union|or\s+1\s*=\s*1)\b', 
            comment, 
            re.IGNORECASE
        )
        if dangerous_in_comment:
            return False
    
    # ШАГ 2: Нормализация SQL и проверка паттернов whitelist
    # normalize_sql() удаляет комментарии и нормализует пробелы
    # Это позволяет сравнивать запросы независимо от форматирования
    normalized = normalize_sql(sql).lower()
    
    # Проверяем каждый паттерн из whitelist
    for pattern in SAFE_QUERY_WHITELIST:
        # re.match() проверяет совпадение с начала строки
        # re.IGNORECASE - регистронезависимое сравнение
        # re.DOTALL - точка соответствует новой строке
        if re.match(pattern, normalized, re.IGNORECASE | re.DOTALL):
            return True  # Запрос соответствует безопасному паттерну
    
    return False  # Запрос не в whitelist

def validate_sql_structure(sql: str) -> tuple[bool, str]:
    """Дополнительная валидация структуры SQL"""
    normalized = normalize_sql(sql)
    s = normalized.lower()
    
    # Проверка на слишком длинные запросы (возможная инъекция)
    if len(normalized) > 10000:
        return False, "Query too long (possible injection attempt)"
    
    # Проверка на подозрительные символы (но разрешаем нормальные переносы строк)
    # Блокируем только действительно опасные символы: NULL, SUB (substitute), но не \n и \r
    suspicious_chars = ['\x00', '\x1a']  # NULL и SUB (substitute)
    for char in suspicious_chars:
        if char in sql:
            return False, f"Suspicious character detected: {repr(char)}"
    
    # Проверка на экранированные кавычки (возможная инъекция)
    if sql.count("'") > 20 or sql.count('"') > 20:
        return False, "Too many quotes (possible injection attempt)"
    
    return True, ""

def validate_sql(sql: str) -> dict:
    """
    ГЛАВНАЯ ФУНКЦИЯ ПРОВЕРКИ SQL ЗАПРОСОВ НА БЕЗОПАСНОСТЬ.
    
    Это центральная точка входа для всех проверок SQL запросов.
    Реализует многослойную защиту (Defense in Depth).
    
    ПОСЛЕДОВАТЕЛЬНОСТЬ ПРОВЕРОК:
    ---------------------------
    1. WHITELIST - быстрая проверка (O(1))
    2. STRUCTURE VALIDATION - проверка структуры
    3. RULE-BASED - проверка известных паттернов
    4. ML-BASED - проверка через машинное обучение
    
    ПРИНЦИП РАБОТЫ:
    --------------
    Запрос проходит через все уровни последовательно.
    Если ЛЮБОЙ уровень блокирует - запрос отклоняется немедленно.
    Только если ВСЕ уровни разрешают - запрос считается безопасным.
    
    АРГУМЕНТЫ:
        sql: str - SQL запрос для проверки
        
    ВОЗВРАЩАЕТ:
        dict - результат проверки:
            {
                "allowed": bool,           # True если разрешен, False если заблокирован
                "layer": str,              # Слой, который разрешил/заблокировал
                "reason": str,             # Причина блокировки (для rule-based)
                "risk_score": float       # Оценка риска (для ML, 0.0-1.0)
            }
    
    ПРИМЕРЫ ВОЗВРАЩАЕМЫХ ЗНАЧЕНИЙ:
        # Разрешен через whitelist
        {"allowed": True, "layer": "whitelist"}
        
        # Заблокирован rule-based
        {"allowed": False, "layer": "rule_based", "reason": "Matched dangerous pattern: UNION"}
        
        # Заблокирован ML
        {"allowed": False, "layer": "ml", "risk_score": 0.991}
        
        # Разрешен после всех проверок
        {"allowed": True}
    
    ПРОИЗВОДИТЕЛЬНОСТЬ:
    ------------------
    - Whitelist: ~0.1ms (regex match)
    - Rule-based: ~1-5ms (несколько regex проверок)
    - ML: ~10-50ms (загрузка модели, предсказание)
    - Общее время: обычно <100ms для большинства запросов
    """
    
    # ========================================================================
    # УРОВЕНЬ 0: WHITELIST ПРОВЕРКА (БЫСТРЫЙ ПУТЬ)
    # ========================================================================
    # 
    # ЦЕЛЬ: Быстро пропустить известные безопасные запросы
    # ПРЕИМУЩЕСТВА: 
    # - Не нужно загружать ML модель
    # - Не нужно выполнять сложные проверки
    # - Предсказуемое поведение для стандартных запросов
    #
    # ЕСЛИ ЗАПРОС В WHITELIST:
    # - Сразу возвращаем разрешение
    # - Не тратим ресурсы на дальнейшие проверки
    if is_whitelisted(sql):
        return {"allowed": True, "layer": "whitelist"}
    
    # ========================================================================
    # УРОВЕНЬ 0.5: СТРУКТУРНАЯ ВАЛИДАЦИЯ
    # ========================================================================
    #
    # ЦЕЛЬ: Отсеять явно подозрительные запросы по структуре
    # ПРОВЕРЯЕТ:
    # - Длину запроса (защита от DoS через очень длинные запросы)
    # - Подозрительные символы (NULL байты, control characters)
    # - Количество кавычек (возможная попытка экранирования)
    #
    # ПРЕИМУЩЕСТВА:
    # - Быстрая проверка (O(n) где n - длина строки)
    # - Защита от DoS атак
    # - Обнаружение базовых проблем до дорогих проверок
    struct_valid, struct_reason = validate_sql_structure(sql)
    if not struct_valid:
        return {
            "allowed": False,
            "layer": "structure_validation",
            "reason": struct_reason
        }
    
    # ========================================================================
    # УРОВЕНЬ 1: RULE-BASED ПРОВЕРКА
    # ========================================================================
    #
    # ЦЕЛЬ: Обнаружить известные паттерны SQL injection атак
    # МЕТОД: Регулярные выражения для поиска опасных паттернов
    # ПАТТЕРНЫ:
    # - UNION SELECT (объединение запросов)
    # - OR 1=1 (boolean-based injection)
    # - pg_sleep (time-based injection)
    # - Stacked queries (множественные запросы через ;)
    # - И другие известные техники
    #
    # ПРЕИМУЩЕСТВА:
    # - Быстрая проверка (regex очень оптимизированы)
    # - Низкая нагрузка на CPU
    # - Обнаруживает большинство известных атак
    #
    # НЕДОСТАТКИ:
    # - Не может обнаружить новые/неизвестные техники
    # - Может быть обойден через обфускацию
    blocked, reason = rule_based_check(sql)
    if blocked:
        return {
            "allowed": False,
            "layer": "rule_based",
            "reason": reason
        }

    # ========================================================================
    # УРОВЕНЬ 2: ML-BASED ПРОВЕРКА
    # ========================================================================
    #
    # ЦЕЛЬ: Обнаружить сложные и новые техники SQL injection
    # МЕТОД: Обученная ML модель (вероятно, классификатор)
    # МОДЕЛЬ: Загружается из sql_injection_model.pkl
    #
    # КАК РАБОТАЕТ:
    # 1. Модель анализирует SQL запрос как текст
    # 2. Извлекает признаки (features) - вероятно, TF-IDF или n-grams
    # 3. Предсказывает вероятность того, что запрос - SQL injection
    # 4. Если вероятность > порога - блокируем
    #
    # АДАПТИВНЫЙ ПОРОГ:
    # - Обычный порог: 0.7367 (настроен на обучении)
    # - Строгий порог: 0.65 (для запросов с подозрительными признаками)
    # - Если запрос содержит UNION, OR 1=1, комментарии и т.д. - используем строгий порог
    #
    # ПРЕИМУЩЕСТВА:
    # - Обнаруживает новые техники, не известные rule-based
    # - Адаптируется к новым атакам через переобучение
    # - Может обнаружить обфусцированные атаки
    #
    # НЕДОСТАТКИ:
    # - Требует обученной модели
    # - Медленнее чем regex (но все еще быстро)
    # - Может быть ложное срабатывание (false positive)
    guard = MLSQLGuard.instance()  # Singleton - одна модель на все приложение
    malicious, score = guard.check(sql)
    if malicious:
        # Запрос определен моделью как вредоносный
        # score - вероятность того, что это SQL injection (0.0 - 1.0)
        # Чем выше score, тем увереннее модель в том, что это атака
        return {
            "allowed": False,
            "layer": "ml",
            "risk_score": round(score, 4)  # Округляем до 4 знаков для читаемости
        }

    # ========================================================================
    # ВСЕ ПРОВЕРКИ ПРОЙДЕНЫ - ЗАПРОС БЕЗОПАСЕН
    # ========================================================================
    #
    # Запрос прошел через все уровни защиты:
    # - Не в whitelist (но это нормально)
    # - Структура валидна
    # - Нет известных паттернов атак
    # - ML модель не определила как вредоносный
    #
    # Возвращаем разрешение
    return {"allowed": True}
