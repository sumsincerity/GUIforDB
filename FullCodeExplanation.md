# Полное объяснение кода проекта

## Введение

Этот документ содержит детальное объяснение всех компонентов проекта системы управления ресторанами с акцентом на безопасность и архитектурные решения.

## Содержание

1. [Общая архитектура](#общая-архитектура)
2. [Система безопасности](#система-безопасности)
3. [Детальное описание файлов](#детальное-описание-файлов)
4. [Принципы проектирования](#принципы-проектирования)
5. [Примеры использования](#примеры-использования)

---

## Общая архитектура

### Технологический стек

#### Backend Framework: Flask

**Почему Flask?**
- Легковесный и гибкий
- Минималистичный подход - добавляем только то, что нужно
- Отличная документация и большое сообщество
- Легко интегрируется с другими библиотеками

**Альтернативы и почему не выбраны:**
- Django: слишком тяжелый для этого проекта, много неиспользуемого функционала
- FastAPI: больше подходит для API, здесь нужен полноценный веб-интерфейс

#### База данных: PostgreSQL

**Почему PostgreSQL?**
- Надежность и ACID гарантии
- Расширяемость (JSON, полнотекстовый поиск, триггеры)
- Отличная производительность
- Бесплатный и open-source

#### Безопасность паролей: bcrypt

**Почему bcrypt?**
- Адаптивный алгоритм - замедляется при увеличении вычислительной мощности
- Защита от brute-force атак
- Проверенный временем алгоритм
- Встроенная защита от timing attacks

**Как работает:**
```python
# Хеширование пароля
hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
# Результат: $2b$12$... (включает соль и параметры)

# Проверка пароля
is_valid = bcrypt.checkpw(password.encode('utf-8'), stored_hash)
# bcrypt автоматически извлекает соль из хеша
```

### Структура приложения

```
┌─────────────────────────────────────────┐
│         HTTP Request (Browser)          │
└──────────────┬──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────────┐
│         Flask Application               │
│  ┌───────────────────────────────────┐  │
│  │  Authentication & Authorization   │  │
│  └──────────────┬────────────────────┘  │
│                 │                        │
│  ┌──────────────▼────────────────────┐  │
│  │  SQL Guard System                 │  │
│  │  (Whitelist → Rule → ML)          │  │
│  └──────────────┬────────────────────┘  │
│                 │                        │
│  ┌──────────────▼────────────────────┐  │
│  │  Database Layer                   │  │
│  │  (Parameterized Queries)          │  │
│  └──────────────┬────────────────────┘  │
└─────────────────┼───────────────────────┘
                  │
                  ▼
         ┌─────────────────┐
         │   PostgreSQL    │
         └─────────────────┘
```

---

## Система безопасности

### Многослойная защита от SQL Injection

#### Уровень 1: Whitelist

**Назначение:** Быстро пропустить известные безопасные запросы

**Как работает:**
- Проверяет SQL запрос на соответствие безопасным паттернам
- Использует регулярные выражения для описания структуры
- Проверяет комментарии на наличие опасных команд

**Преимущества:**
- O(1) сложность проверки
- Не требует загрузки ML модели
- Предсказуемое поведение

**Примеры паттернов:**
```python
r"^\s*select\s+\*\s+from\s+\w+\s*;?\s*$"  # SELECT * FROM table
r"^\s*select\s+[\w\s,]+from\s+\w+\s+where\s+..."  # SELECT с WHERE
```

#### Уровень 2: Structure Validation

**Назначение:** Отсеять явно подозрительные запросы по структуре

**Проверки:**
- Длина запроса (максимум 10000 символов)
- Подозрительные символы (NULL байты, control characters)
- Количество кавычек (защита от экранирования)

**Почему важно:**
- Защита от DoS через очень длинные запросы
- Обнаружение базовых проблем до дорогих проверок
- Быстрая проверка (O(n) где n - длина строки)

#### Уровень 3: Rule-based

**Назначение:** Обнаружить известные паттерны SQL injection

**Паттерны:**
- UNION SELECT - объединение запросов
- OR 1=1 - boolean-based injection
- pg_sleep() - time-based injection
- Stacked queries - множественные запросы через ;

**Как работает:**
```python
# Пример паттерна
r"\bunion\b\s+all\s+\bselect\b"  # UNION ALL SELECT

# Проверка
if re.search(pattern, sql, re.IGNORECASE):
    return True, "Matched dangerous pattern"
```

**Преимущества:**
- Быстрая проверка (regex оптимизированы)
- Низкая нагрузка на CPU
- Обнаруживает большинство известных атак

#### Уровень 4: ML-based

**Назначение:** Обнаружить сложные и новые техники

**Как работает:**
1. Модель анализирует SQL как текст
2. Извлекает признаки (вероятно, TF-IDF векторизация)
3. Предсказывает вероятность SQL injection
4. Если вероятность > порога - блокирует

**Адаптивный порог:**
- Обычный: 0.7367 (для стандартных запросов)
- Строгий: 0.65 (для подозрительных запросов)

**Преимущества:**
- Обнаруживает новые техники
- Может обнаружить обфусцированные атаки
- Адаптируется через переобучение

### Валидация идентификаторов

#### validate_table_name()

**Проблема:** Пользователь может ввести имя таблицы напрямую в SQL

**Решение:** Whitelist подход
1. Проверка формата (regex)
2. Проверка существования в БД
3. Никогда не используем напрямую в SQL

**Пример атаки:**
```python
# Атакующий вводит:
table_name = "users; DROP TABLE orders; --"

# Без защиты:
sql = f"SELECT * FROM {table_name}"  # ОПАСНО!

# С защитой:
is_valid, error = validate_table_name(table_name)  # False!
# Запрос блокируется
```

#### validate_column_names()

**Аналогично validate_table_name()**, но для списка колонок

**Дополнительная проверка:**
- Каждая колонка должна существовать в указанной таблице
- Получаем список колонок из information_schema

---

## Детальное описание файлов

### web_app.py

**Назначение:** Главный файл Flask приложения

**Основные компоненты:**

1. **Конфигурация Flask**
   ```python
   app = Flask(__name__)
   app.secret_key = os.environ.get("SECRET_KEY")
   ```

2. **Система ролей (RBAC)**
   ```python
   ROLE_PERMISSIONS = {
       "admin": {"admin", "tables", "query", ...},
       "waiter": {"orders", "menu"},
   }
   ```

3. **Функции безопасности**
   - `validate_table_name()` - валидация имен таблиц
   - `validate_column_names()` - валидация имен колонок
   - `validate_where_clause()` - валидация WHERE условий
   - `validate_username_input()` - валидация username

4. **HTTP эндпоинты**
   - `/login` - авторизация
   - `/dashboard` - главная страница
   - `/action/query/run` - выполнение SQL запросов
   - И другие...

### app/security/sql_guard.py

**Назначение:** Главная система защиты от SQL injection

**Функции:**

1. **validate_sql()** - главная функция проверки
   - Последовательно применяет все уровни защиты
   - Возвращает результат с указанием слоя

2. **is_whitelisted()** - проверка whitelist
   - Проверяет комментарии на опасные команды
   - Сопоставляет с безопасными паттернами

3. **validate_sql_structure()** - проверка структуры
   - Длина, символы, кавычки

### app/security/rule_based.py

**Назначение:** Rule-based проверки на основе regex

**Компоненты:**

1. **DANGEROUS_PATTERNS** - список опасных паттернов
2. **FORBIDDEN_KEYWORDS** - запрещенные ключевые слова
3. **normalize_sql()** - нормализация SQL
4. **rule_based_check()** - главная функция проверки

### app/security/ml_guard.py

**Назначение:** ML-based проверка через обученную модель

**Паттерн:** Singleton для единственного экземпляра модели

**Методы:**
- `instance()` - получение экземпляра (Singleton)
- `check()` - проверка SQL запроса
- `_has_suspicious_features()` - обнаружение подозрительных признаков

---

## Принципы проектирования

### 1. Defense in Depth (Защита в глубину)

Множественные уровни защиты на случай, если один слой пропустит атаку.

**Пример:**
```
Запрос: "SELECT * FROM users UNION SELECT * FROM passwords"
├─ Whitelist: не проходит (не в whitelist)
├─ Structure: проходит (структура валидна)
├─ Rule-based: БЛОКИРУЕТ (обнаружен UNION SELECT)
└─ ML: не проверяется (уже заблокирован)
```

### 2. Fail-Safe Defaults

По умолчанию блокируем, разрешаем только явно безопасное.

**Пример:**
```python
# Если модель не загрузилась
except Exception:
    return True, 1.0  # Блокируем (fail-safe)
```

### 3. Principle of Least Privilege

Пользователи получают минимально необходимые права.

**Пример:**
```python
"waiter": {"orders", "menu"}  # Только заказы и меню
"admin": {"admin", "tables", "query", ...}  # Все права
```

### 4. Whitelist over Blacklist

Разрешаем только известное безопасное, вместо блокировки известного опасного.

**Почему:**
- Blacklist: нужно знать все возможные атаки
- Whitelist: нужно знать только безопасные паттерны
- Whitelist более безопасен

---

## Примеры использования

### Пример 1: Выполнение SQL запроса

```python
# Пользователь вводит SQL
sql = "SELECT * FROM orders WHERE status = 'completed'"

# Проверка через guard систему
result = validate_sql(sql)

if result["allowed"]:
    # Запрос безопасен, выполняем
    cur.execute(sql)
else:
    # Запрос заблокирован
    flash(f"Запрос заблокирован: {result['reason']}")
```

### Пример 2: Валидация имени таблицы

```python
# Пользователь выбирает таблицу
table_name = request.form.get("table")

# Валидация
is_valid, error = validate_table_name(table_name)

if not is_valid:
    flash(f"Ошибка: {error}")
    return redirect(...)

# Безопасно используем в SQL
sql = f"SELECT * FROM {table_name}"  # table_name проверен
```

### Пример 3: Создание пользователя (только админ)

```python
@app.post("/action/users/create")
@login_required
def action_users_create():
    # Проверка прав
    if not has_perm("admin"):
        flash("Нет доступа")
        return redirect(...)
    
    # Валидация username
    username = request.form.get("username")
    is_valid, error = validate_username_input(username)
    
    if not is_valid:
        flash(f"Ошибка: {error}")
        return redirect(...)
    
    # Безопасное создание через параметризованный запрос
    cur.execute(
        "INSERT INTO app_users(username, password_hash) VALUES (%s, %s)",
        (username, password_hash)  # Параметры, не строка
    )
```

---

## Заключение

Проект реализует комплексную систему безопасности с многослойной защитой от SQL injection. Все компоненты документированы и содержат подробные комментарии для понимания архитектуры и логики работы.

